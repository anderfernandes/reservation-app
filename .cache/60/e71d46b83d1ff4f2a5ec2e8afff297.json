{"id":"node_modules/semantic-ui-vue/dist/commonjs/modules/Popup/private/PopupContainer.js","dependencies":[{"name":"/home/anderson/reservation-app/package.json","includedInParent":true,"mtime":1565037056203},{"name":"/home/anderson/reservation-app/node_modules/semantic-ui-vue/package.json","includedInParent":true,"mtime":1564431753732},{"name":"lodash/mapValues","loc":{"line":7,"column":25},"parent":"/home/anderson/reservation-app/node_modules/semantic-ui-vue/dist/commonjs/modules/Popup/private/PopupContainer.js","resolved":"/home/anderson/reservation-app/node_modules/lodash/mapValues.js"},{"name":"lodash/without","loc":{"line":11,"column":23},"parent":"/home/anderson/reservation-app/node_modules/semantic-ui-vue/dist/commonjs/modules/Popup/private/PopupContainer.js","resolved":"/home/anderson/reservation-app/node_modules/lodash/without.js"},{"name":"../../../lib","loc":{"line":15,"column":19},"parent":"/home/anderson/reservation-app/node_modules/semantic-ui-vue/dist/commonjs/modules/Popup/private/PopupContainer.js","resolved":"/home/anderson/reservation-app/node_modules/semantic-ui-vue/dist/commonjs/lib/index.js"},{"name":"./popupConstants","loc":{"line":17,"column":30},"parent":"/home/anderson/reservation-app/node_modules/semantic-ui-vue/dist/commonjs/modules/Popup/private/PopupContainer.js","resolved":"/home/anderson/reservation-app/node_modules/semantic-ui-vue/dist/commonjs/modules/Popup/private/popupConstants.js"}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _mapValues = require('lodash/mapValues');\n\nvar _mapValues2 = _interopRequireDefault(_mapValues);\n\nvar _without = require('lodash/without');\n\nvar _without2 = _interopRequireDefault(_without);\n\nvar _lib = require('../../../lib');\n\nvar _popupConstants = require('./popupConstants');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nexports.default = {\n  name: 'SuiPrivatePopupContainer',\n  mixins: [_lib.SemanticUIVueMixin],\n  props: {\n    popupClass: String,\n    triggerCoords: _lib.isBrowser ? [window.DOMRect, Object] : Object,\n    position: String\n  },\n  data: function data() {\n    return {\n      mountedPosition: this.position,\n      mountedStyle: null\n    };\n  },\n  mounted: function mounted() {\n    var _this = this;\n\n    this.$nextTick(function () {\n      _this.popupCoords = _this.$refs.container.getBoundingClientRect();\n\n      _this.setPopupStyle();\n    });\n  },\n  methods: {\n    computePopupStyle: function computePopupStyle(positions) {\n      var style = {\n        position: 'absolute'\n      }; // Do not access window/document when server side rendering\n\n      if (!_lib.isBrowser) return style;\n      var offset = this.offset;\n      var _window = window,\n          pageYOffset = _window.pageYOffset,\n          pageXOffset = _window.pageXOffset;\n      var _document$documentEle = document.documentElement,\n          clientWidth = _document$documentEle.clientWidth,\n          clientHeight = _document$documentEle.clientHeight;\n\n      if (positions.includes('right')) {\n        style.right = Math.round(clientWidth - (this.triggerCoords.right + pageXOffset));\n        style.left = 'auto';\n      } else if (positions.includes('left')) {\n        style.left = Math.round(this.triggerCoords.left + pageXOffset);\n        style.right = 'auto';\n      } else {\n        // if not left nor right, we are horizontally centering the element\n        var xOffset = (this.triggerCoords.width - this.popupCoords.width) / 2;\n        style.left = Math.round(this.triggerCoords.left + xOffset + pageXOffset);\n        style.right = 'auto';\n      }\n\n      if (positions.includes('top')) {\n        style.bottom = Math.round(clientHeight - (this.triggerCoords.top + pageYOffset));\n        style.top = 'auto';\n      } else if (positions.includes('bottom')) {\n        style.top = Math.round(this.triggerCoords.bottom + pageYOffset);\n        style.bottom = 'auto';\n      } else {\n        // if not top nor bottom, we are vertically centering the element\n        var yOffset = (this.triggerCoords.height + this.popupCoords.height) / 2;\n        style.top = Math.round(this.triggerCoords.bottom + pageYOffset - yOffset);\n        style.bottom = 'auto';\n\n        var _xOffset = this.popupCoords.width + 8;\n\n        if (positions.includes('right')) {\n          style.right -= _xOffset;\n        } else {\n          style.left -= _xOffset;\n        }\n      }\n\n      if (offset) {\n        if (typeof style.right === 'number') {\n          style.right -= offset;\n        } else {\n          style.left -= offset;\n        }\n      }\n\n      return style;\n    },\n    isStyleInViewport: function isStyleInViewport(style) {\n      var _window2 = window,\n          pageYOffset = _window2.pageYOffset,\n          pageXOffset = _window2.pageXOffset;\n      var _document$documentEle2 = document.documentElement,\n          clientWidth = _document$documentEle2.clientWidth,\n          clientHeight = _document$documentEle2.clientHeight;\n      var element = {\n        top: style.top,\n        left: style.left,\n        width: this.popupCoords.width,\n        height: this.popupCoords.height\n      };\n\n      if (typeof style.right === 'number') {\n        element.left = clientWidth - style.right - element.width;\n      }\n\n      if (typeof style.bottom === 'number') {\n        element.top = clientHeight - style.bottom - element.height;\n      } // hidden on top\n\n\n      if (element.top < pageYOffset) return false; // hidden on the bottom\n\n      if (element.top + element.height > pageYOffset + clientHeight) return false; // hidden the left\n\n      if (element.left < pageXOffset) return false; // hidden on the right\n\n      if (element.left + element.width > pageXOffset + clientWidth) return false;\n      return true;\n    },\n    setPopupStyle: function setPopupStyle() {\n      if (!this.triggerCoords || !this.popupCoords) return;\n      var position = this.position;\n      var style = this.computePopupStyle(position); // Lets detect if the popup is out of the viewport and adjust\n      // the position accordingly\n\n      var positions = (0, _without2.default)(_popupConstants.POSITIONS, position).concat([position]);\n\n      for (var i = 0; !this.isStyleInViewport(style) && i < positions.length; i += 1) {\n        style = this.computePopupStyle(positions[i]);\n        position = positions[i];\n      } // Append 'px' to every numerical values in the style\n\n\n      style = (0, _mapValues2.default)(style, function (value) {\n        return typeof value === 'number' ? value + 'px' : value;\n      });\n      this.mountedStyle = style;\n      this.mountedPosition = position;\n    }\n  },\n  render: function render() {\n    var _this2 = this;\n\n    var h = arguments[0];\n    var className = this.classes('ui', this.mountedPosition, this.popupClass, 'popup', 'transition visible');\n    return h('portal', {\n      attrs: {\n        to: 'semantic-ui-vue'\n      }\n    }, [h('div', {\n      ref: 'container',\n      'class': className,\n      style: this.mountedStyle,\n      on: {\n        'mouseover': function mouseover() {\n          return _this2.$emit('mouseover');\n        },\n        'mouseleave': function mouseleave() {\n          return _this2.$emit('mouseleave');\n        }\n      }\n    }, [this.$slots.default])]);\n  }\n};"},"sourceMaps":null,"error":null,"hash":"227e2865eb4a0abaa70fc0d965d31544","cacheData":{"env":{}}}